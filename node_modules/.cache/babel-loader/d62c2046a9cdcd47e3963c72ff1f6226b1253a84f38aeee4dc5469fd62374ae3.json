{"ast":null,"code":"// // import {mergeSort, quickSort, insertionSort, bubbleSort, selectionSort} from './Algorithms';\n\n// var arr = [34, 23];\n// var block = '<div class=\"block\"></div>';\n// var piles = '<div class=\"pile\"></div>';\n// var q = document.querySelector(\".numbers\");\n\n// var drawUnique = (i, j) => {\n//     var q1 = document.getElementsByClassName(\"block\")[i]\n//     var q2 = document.getElementsByClassName(\"block\")[j]\n\n//     for (let i = 0; i < q1.childNodes.length; i++) {\n//         q1.childNodes[i].className = \"un1\";\n//     }\n//     for (let i = 0; i < q2.childNodes.length; i++) {\n//         q2.childNodes[i].className = \"un2\";\n//     }\n// }\n\n// var drawSame = (i, j) => {\n//     var q1 = document.getElementsByClassName(\"block\")[i]\n//     var q2 = document.getElementsByClassName(\"block\")[j]\n\n//     for (let i = 0; i < q1.childNodes.length; i++) {\n//         q1.childNodes[i].className = \"pile\";\n//     }\n//     for (let i = 0; i < q2.childNodes.length; i++) {\n//         q2.childNodes[i].className = \"pile\";\n//     }\n// }\n\n// var swap = (i1, i2) => {\n//     var q1 = document.getElementsByClassName(\"block\")[i1]\n//     var q2 = document.getElementsByClassName(\"block\")[i2]\n\n//     var temp = q1.innerHTML\n//     q1.innerHTML = q2.innerHTML\n//     q2.innerHTML = temp\n// }\n\n// const validate = () => {\n//     let q = document.querySelector(\"#array\")\n//     var alertMsg = \"\"\n//     var num = q.value.split(\" \").map(x => parseInt(x)); \n//     for (let i = 0; i < num.length; i++) {\n//         if(isNaN(num[i])){\n//             alertMsg = \"Invalid Input\"\n//             break\n//         }\n//     }\n//     console.log(\"called\");\n//     if(alertMsg!=\"\"){\n//         alert(alertMsg)\n//     }\n//     else{\n//         simulate(num)\n//     }\n// }\n\n// let simulate = (arr) => {\n//     draw(arr)\n\n//     var q = document.querySelector(\"#sortingAlgo\")\n//     let algo = q.value\n//     if(algo==\"insertion\")\n//         insertionSort(arr)\n//     else if(algo == \"selection\")\n//         selectionSort(arr)\n//     else if(algo == \"bubble\")\n//         bubbleSort(arr)   \n//     else if(algo == \"quick\")\n//         quickSort(arr)\n//     else if(algo == \"merge\")\n//         mergeSort(arr)\n// }\n\n// // import {simulate, validate, swap, drawSame, drawUnique} from './Sorting';\n\n// async function selectionSort(arr) {\n//     let n = arr.length;\n\n//     for(let i = 0; i < n; i++) {\n//         let min = i;\n//         for(let j = i+1; j < n; j++){\n//             if(arr[j] < arr[min]) {\n//                 min=j; \n//             }\n//          }\n//          if (min != i) {\n//             drawUnique(i, min)\n//             let tmp = arr[i]; \n//             arr[i] = arr[min];\n//             arr[min] = tmp;\n//             await sleep(200)\n//             swap(i, min)\n//             await sleep(100)\n//             drawSame(i, min)      \n//         }\n//     }\n// }\n\n// async function bubbleSort(arr) {\n//     for (var i = 0; i < arr.length; i++) {\n//         for (var j = 0; j < (arr.length - i - 1); j++) {\n//             if (arr[j] > arr[j + 1]) {\n\n//                 drawUnique(j, j+1)\n\n//                 var temp = arr[j]\n//                 arr[j] = arr[j + 1]\n//                 arr[j + 1] = temp\n\n//                 await sleep(200)\n//                 swap(j, j+1)\n//                 await sleep(100)\n//                 drawSame(j, j+1)  \n//             }\n//         }\n//     }\n// }\n\n// async function insertionSort(arr) {\n//     for (let i = 1; i < arr.length; i++) {\n//         let j = i - 1;\n//         let temp = arr[i];\n//         while (j >= 0 && arr[j] > temp) {\n//             drawUnique(j, j+1)\n//             arr[j + 1] = arr[j];\n//             await sleep(200)\n//             swap(j, j+1)\n//             await sleep(100)\n//             drawSame(j, j+1) \n//             j--;\n//         }\n//         arr[j + 1] = temp;\n//     }\n// }\n\n// async function quickSort(arr) {\n//     let l = 0\n//     let h = arr.length-1;\n//     let n = arr.lenght\n//     let stack = new Array(h - l + 1);\n//     stack.fill(0);\n//     let top = -1;\n//     stack[++top] = l;\n//     stack[++top] = h;\n//     while (top >= 0) {\n//         h = stack[top--];\n//         l = stack[top--];\n//         let temp;\n//         let pivot = arr[h];\n//         let i = (l - 1);\n//         for (let j = l; j <= h - 1; j++) {\n//             if (arr[j] <= pivot) {\n//                 i++;\n\n//                 drawUnique(i, j)\n\n//                 temp = arr[i];\n//                 arr[i] = arr[j];\n//                 arr[j] = temp;\n\n//                 await sleep(200)\n//                 swap(i, j)\n//                 await sleep(100)\n//                 drawSame(i, j)    \n//             }\n//         }\n\n//         drawUnique(i+1, h)\n\n//         temp = arr[i + 1];\n//         arr[i + 1] = arr[h];\n//         arr[h] = temp;\n\n//         await sleep(200)\n//         swap(i+1, h)\n//         await sleep(100)\n//         drawSame(i+1, h)\n\n//         let p = i + 1;;\n//         if (p - 1 > l) {\n//             stack[++top] = l;\n//             stack[++top] = p - 1;\n//         }\n//         if (p + 1 < h) {\n//             stack[++top] = p + 1;\n//             stack[++top] = h;\n//         }\n//     }\n// }\n\n// async function mergeSort(arr) {\n//     let n = arr.length;\n//     let temp = new Array(n);\n//     for (let i = 0; i < n; i++) {\n//         temp[i] = arr[i];\n//     }\n//     let l = 0;\n//     let h = n - 1;\n//     let m = Math.floor((l + h) / 2);\n//     let i = 0;\n//     let j = m + 1;\n//     while (i <= m && j <= h) {\n//         if (temp[i] <= temp[j]) {\n//             drawUnique(i, j)\n//             arr[i] = temp[i];\n//             i++;\n//         } else {\n//             drawUnique(i, j)\n//             arr[j] = temp[j];\n//             j++;\n//         }\n//         await sleep(200)\n//         swap(i, j)\n//         await sleep(100)\n//         drawSame(i, j)\n//     }\n//     while (i <= m) {\n//         drawUnique(i, j)\n//         arr[j] = temp[i];\n//         j++;\n//         i++;\n//         await sleep(200)\n//         swap(i, j)\n//         await sleep(100)\n//         drawSame(i, j)\n//     }\n//     while (j <= h) {\n//         drawUnique(i, j)\n//         arr[j] = temp[j];\n//         j++;\n//         await sleep(200)\n//         swap(i, j)\n//         await sleep(100)\n//         drawSame(i, j)\n//     }\n// }\n\n// function generateArray(){\n//     var size = 10;\n//     let n\n//     let q = document.querySelector(\"#array\")\n//     q.value = \"\"\n//     for (let i = 0; i < size; i++) {\n//         n = Math.floor((Math.random() * 50) + 1);\n//         q.value += n\n//         if(i<size-1){\n//             q.value += \", \"\n//         }\n//     }\n// }\n\n// var draw = (arr) => {\n//     q.innerHTML = \"\";\n//     for (let i = 0; i < arr.length; i++) {\n//         const p = arr[i];\n//         q.innerHTML += block;\n//         var j = document.getElementsByClassName(\"block\")[i];\n//         for(let k=0; k<p; k++){\n//             j.innerHTML += piles;\n//         }\n//     }\n// };\n\n// function sleep(milliseconds) {  \n//     return new Promise(resolve => setTimeout(resolve, milliseconds));  \n// }\n\n// let scene, camera, renderer, cube;\n// // function init () {\n// //     scene = new THREE.Scene();\n// //     scene.background = new THREE.Color( 0xff0000 );\n\n// //     camera = new THREE.PerspectiveCamera(75, window.innerWidth/ window.innerHeight, 0.1, 1000);\n\n// //     renderer = new THREE.WebGLRenderer({antialias: true});\n\n// //     renderer.setSize(window.innerWidth, window.innerHeight);\n\n// //     document.body.appendChild(renderer.domElement);\n\n// //     const geometry = new THREE.BoxGeometry( 1, 1, 1 );\n// //     const material = new THREE.MeshBasicMaterial( {color: 0x000645} );\n// //     cube = new THREE.Mesh( geometry, material );\n// //     scene.add( cube );\n\n// //     camera.position.z = 5;\n\n// // }\n\n// function animate () {\n//     requestAnimationFrame(animate);\n//     cube.rotation.x += 0.01;\n//     cube.rotation.y += 0.01;\n//     renderer.render(scene, camera);\n// }\n\n// function onWindowResize() {\n//     camera.aspect = window.innerWidth / window.innerHeight;\n//     camera.updateProjectionMatrix();\n//     renderer.setSize(window.innerWidth, window.innerHeight);\n// }\n\n// window.addEventListener('resize', onWindowResize, false)\n\n// // init();\n// // animate();\n\n// export {mergeSort, quickSort, insertionSort, bubbleSort, selectionSort};\n// export {simulate, validate, swap, drawSame, drawUnique, generateArray,sleep, draw, animate, onWindowResize};","map":{"version":3,"names":[],"sources":["C:/Users/91830/OneDrive/Desktop/sort-and-see/sorting-visualiser/src/Components/Algos/Sorting.js"],"sourcesContent":["// // import {mergeSort, quickSort, insertionSort, bubbleSort, selectionSort} from './Algorithms';\r\n\r\n// var arr = [34, 23];\r\n// var block = '<div class=\"block\"></div>';\r\n// var piles = '<div class=\"pile\"></div>';\r\n// var q = document.querySelector(\".numbers\");\r\n\r\n// var drawUnique = (i, j) => {\r\n//     var q1 = document.getElementsByClassName(\"block\")[i]\r\n//     var q2 = document.getElementsByClassName(\"block\")[j]\r\n\r\n//     for (let i = 0; i < q1.childNodes.length; i++) {\r\n//         q1.childNodes[i].className = \"un1\";\r\n//     }\r\n//     for (let i = 0; i < q2.childNodes.length; i++) {\r\n//         q2.childNodes[i].className = \"un2\";\r\n//     }\r\n// }\r\n\r\n// var drawSame = (i, j) => {\r\n//     var q1 = document.getElementsByClassName(\"block\")[i]\r\n//     var q2 = document.getElementsByClassName(\"block\")[j]\r\n\r\n//     for (let i = 0; i < q1.childNodes.length; i++) {\r\n//         q1.childNodes[i].className = \"pile\";\r\n//     }\r\n//     for (let i = 0; i < q2.childNodes.length; i++) {\r\n//         q2.childNodes[i].className = \"pile\";\r\n//     }\r\n// }\r\n\r\n// var swap = (i1, i2) => {\r\n//     var q1 = document.getElementsByClassName(\"block\")[i1]\r\n//     var q2 = document.getElementsByClassName(\"block\")[i2]\r\n\r\n//     var temp = q1.innerHTML\r\n//     q1.innerHTML = q2.innerHTML\r\n//     q2.innerHTML = temp\r\n// }\r\n\r\n\r\n\r\n// const validate = () => {\r\n//     let q = document.querySelector(\"#array\")\r\n//     var alertMsg = \"\"\r\n//     var num = q.value.split(\" \").map(x => parseInt(x)); \r\n//     for (let i = 0; i < num.length; i++) {\r\n//         if(isNaN(num[i])){\r\n//             alertMsg = \"Invalid Input\"\r\n//             break\r\n//         }\r\n//     }\r\n//     console.log(\"called\");\r\n//     if(alertMsg!=\"\"){\r\n//         alert(alertMsg)\r\n//     }\r\n//     else{\r\n//         simulate(num)\r\n//     }\r\n// }\r\n\r\n// let simulate = (arr) => {\r\n//     draw(arr)\r\n\r\n    \r\n//     var q = document.querySelector(\"#sortingAlgo\")\r\n//     let algo = q.value\r\n//     if(algo==\"insertion\")\r\n//         insertionSort(arr)\r\n//     else if(algo == \"selection\")\r\n//         selectionSort(arr)\r\n//     else if(algo == \"bubble\")\r\n//         bubbleSort(arr)   \r\n//     else if(algo == \"quick\")\r\n//         quickSort(arr)\r\n//     else if(algo == \"merge\")\r\n//         mergeSort(arr)\r\n// }\r\n\r\n// // import {simulate, validate, swap, drawSame, drawUnique} from './Sorting';\r\n\r\n// async function selectionSort(arr) {\r\n//     let n = arr.length;\r\n        \r\n//     for(let i = 0; i < n; i++) {\r\n//         let min = i;\r\n//         for(let j = i+1; j < n; j++){\r\n//             if(arr[j] < arr[min]) {\r\n//                 min=j; \r\n//             }\r\n//          }\r\n//          if (min != i) {\r\n//             drawUnique(i, min)\r\n//             let tmp = arr[i]; \r\n//             arr[i] = arr[min];\r\n//             arr[min] = tmp;\r\n//             await sleep(200)\r\n//             swap(i, min)\r\n//             await sleep(100)\r\n//             drawSame(i, min)      \r\n//         }\r\n//     }\r\n// }\r\n\r\n// async function bubbleSort(arr) {\r\n//     for (var i = 0; i < arr.length; i++) {\r\n//         for (var j = 0; j < (arr.length - i - 1); j++) {\r\n//             if (arr[j] > arr[j + 1]) {\r\n\r\n\r\n//                 drawUnique(j, j+1)\r\n\r\n//                 var temp = arr[j]\r\n//                 arr[j] = arr[j + 1]\r\n//                 arr[j + 1] = temp\r\n\r\n//                 await sleep(200)\r\n//                 swap(j, j+1)\r\n//                 await sleep(100)\r\n//                 drawSame(j, j+1)  \r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n\r\n// async function insertionSort(arr) {\r\n//     for (let i = 1; i < arr.length; i++) {\r\n//         let j = i - 1;\r\n//         let temp = arr[i];\r\n//         while (j >= 0 && arr[j] > temp) {\r\n//             drawUnique(j, j+1)\r\n//             arr[j + 1] = arr[j];\r\n//             await sleep(200)\r\n//             swap(j, j+1)\r\n//             await sleep(100)\r\n//             drawSame(j, j+1) \r\n//             j--;\r\n//         }\r\n//         arr[j + 1] = temp;\r\n//     }\r\n// }\r\n\r\n// async function quickSort(arr) {\r\n//     let l = 0\r\n//     let h = arr.length-1;\r\n//     let n = arr.lenght\r\n//     let stack = new Array(h - l + 1);\r\n//     stack.fill(0);\r\n//     let top = -1;\r\n//     stack[++top] = l;\r\n//     stack[++top] = h;\r\n//     while (top >= 0) {\r\n//         h = stack[top--];\r\n//         l = stack[top--];\r\n//         let temp;\r\n//         let pivot = arr[h];\r\n//         let i = (l - 1);\r\n//         for (let j = l; j <= h - 1; j++) {\r\n//             if (arr[j] <= pivot) {\r\n//                 i++;\r\n\r\n//                 drawUnique(i, j)\r\n\r\n\r\n//                 temp = arr[i];\r\n//                 arr[i] = arr[j];\r\n//                 arr[j] = temp;\r\n\r\n//                 await sleep(200)\r\n//                 swap(i, j)\r\n//                 await sleep(100)\r\n//                 drawSame(i, j)    \r\n//             }\r\n//         }\r\n\r\n//         drawUnique(i+1, h)\r\n\r\n//         temp = arr[i + 1];\r\n//         arr[i + 1] = arr[h];\r\n//         arr[h] = temp;\r\n\r\n//         await sleep(200)\r\n//         swap(i+1, h)\r\n//         await sleep(100)\r\n//         drawSame(i+1, h)\r\n\r\n//         let p = i + 1;;\r\n//         if (p - 1 > l) {\r\n//             stack[++top] = l;\r\n//             stack[++top] = p - 1;\r\n//         }\r\n//         if (p + 1 < h) {\r\n//             stack[++top] = p + 1;\r\n//             stack[++top] = h;\r\n//         }\r\n//     }\r\n// }\r\n\r\n// async function mergeSort(arr) {\r\n//     let n = arr.length;\r\n//     let temp = new Array(n);\r\n//     for (let i = 0; i < n; i++) {\r\n//         temp[i] = arr[i];\r\n//     }\r\n//     let l = 0;\r\n//     let h = n - 1;\r\n//     let m = Math.floor((l + h) / 2);\r\n//     let i = 0;\r\n//     let j = m + 1;\r\n//     while (i <= m && j <= h) {\r\n//         if (temp[i] <= temp[j]) {\r\n//             drawUnique(i, j)\r\n//             arr[i] = temp[i];\r\n//             i++;\r\n//         } else {\r\n//             drawUnique(i, j)\r\n//             arr[j] = temp[j];\r\n//             j++;\r\n//         }\r\n//         await sleep(200)\r\n//         swap(i, j)\r\n//         await sleep(100)\r\n//         drawSame(i, j)\r\n//     }\r\n//     while (i <= m) {\r\n//         drawUnique(i, j)\r\n//         arr[j] = temp[i];\r\n//         j++;\r\n//         i++;\r\n//         await sleep(200)\r\n//         swap(i, j)\r\n//         await sleep(100)\r\n//         drawSame(i, j)\r\n//     }\r\n//     while (j <= h) {\r\n//         drawUnique(i, j)\r\n//         arr[j] = temp[j];\r\n//         j++;\r\n//         await sleep(200)\r\n//         swap(i, j)\r\n//         await sleep(100)\r\n//         drawSame(i, j)\r\n//     }\r\n// }\r\n\r\n// function generateArray(){\r\n//     var size = 10;\r\n//     let n\r\n//     let q = document.querySelector(\"#array\")\r\n//     q.value = \"\"\r\n//     for (let i = 0; i < size; i++) {\r\n//         n = Math.floor((Math.random() * 50) + 1);\r\n//         q.value += n\r\n//         if(i<size-1){\r\n//             q.value += \", \"\r\n//         }\r\n//     }\r\n// }\r\n\r\n// var draw = (arr) => {\r\n//     q.innerHTML = \"\";\r\n//     for (let i = 0; i < arr.length; i++) {\r\n//         const p = arr[i];\r\n//         q.innerHTML += block;\r\n//         var j = document.getElementsByClassName(\"block\")[i];\r\n//         for(let k=0; k<p; k++){\r\n//             j.innerHTML += piles;\r\n//         }\r\n//     }\r\n// };\r\n\r\n// function sleep(milliseconds) {  \r\n//     return new Promise(resolve => setTimeout(resolve, milliseconds));  \r\n// }\r\n\r\n// let scene, camera, renderer, cube;\r\n// // function init () {\r\n// //     scene = new THREE.Scene();\r\n// //     scene.background = new THREE.Color( 0xff0000 );\r\n\r\n// //     camera = new THREE.PerspectiveCamera(75, window.innerWidth/ window.innerHeight, 0.1, 1000);\r\n    \r\n// //     renderer = new THREE.WebGLRenderer({antialias: true});\r\n    \r\n// //     renderer.setSize(window.innerWidth, window.innerHeight);\r\n    \r\n// //     document.body.appendChild(renderer.domElement);\r\n    \r\n// //     const geometry = new THREE.BoxGeometry( 1, 1, 1 );\r\n// //     const material = new THREE.MeshBasicMaterial( {color: 0x000645} );\r\n// //     cube = new THREE.Mesh( geometry, material );\r\n// //     scene.add( cube );\r\n    \r\n// //     camera.position.z = 5;\r\n\r\n \r\n// // }\r\n\r\n\r\n// function animate () {\r\n//     requestAnimationFrame(animate);\r\n//     cube.rotation.x += 0.01;\r\n//     cube.rotation.y += 0.01;\r\n//     renderer.render(scene, camera);\r\n// }\r\n\r\n// function onWindowResize() {\r\n//     camera.aspect = window.innerWidth / window.innerHeight;\r\n//     camera.updateProjectionMatrix();\r\n//     renderer.setSize(window.innerWidth, window.innerHeight);\r\n// }\r\n\r\n// window.addEventListener('resize', onWindowResize, false)\r\n\r\n\r\n// // init();\r\n// // animate();\r\n\r\n\r\n// export {mergeSort, quickSort, insertionSort, bubbleSort, selectionSort};\r\n// export {simulate, validate, swap, drawSame, drawUnique, generateArray,sleep, draw, animate, onWindowResize};"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAGA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AACA;;AAGA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}